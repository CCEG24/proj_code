{% extends "base.html" %}

{% block title %}Flappy Bird{% endblock %}
{% block header %}Flappy Bird{% endblock %}

{% block content %}
<style>
    .game-container {
        margin: 0;
        overflow: hidden;
        background-color: #70c5ce;
        touch-action: manipulation;
        text-align: center;
        padding: 20px;
    }

    canvas {
        display: block;
        margin: 0 auto;
        background: #70c5ce;
        border: 2px solid #333;
        border-radius: 10px;
    }
    
    .game-instructions {
        color: white;
        margin-bottom: 10px;
        font-size: 18px;
    }
</style>

<div class="game-container">
    <p class="game-instructions">Click or tap to make the bird flap! Avoid the pipes!</p>
    <div style="margin-bottom: 10px;">
        <a href="{% url 'flappyBird:leaderboard' %}" style="color: white; text-decoration: none; background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;">View Leaderboard</a>
    </div>
<canvas id="gameCanvas" width="400" height="600"></canvas>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // Constants
  const GRAVITY = 0.3;
  const FLAP = -3;
  const PIPE_WIDTH = 50;
  const PIPE_GAP = 170;
  const PIPE_SPACING = 170;
  const PIPE_SPEED = 3;
  const BIRD_SIZE = 30;

  // Game state
  let birdY = 200;
  let birdVelocity = 0;
  let pipes = [];
  let score = 0;
  let highScore = parseInt(localStorage.getItem("highScore")) || 0;
  let gameOver = false;
  let scoreSaved = false;  // Track if score has been saved to prevent duplicates
  let frames = 0;
  let flapQueued = false;

  const birdColor = "#FFD700";
  const pipeColor = "#228B22";

  function resetGame() {
    if (score > highScore) {
      highScore = score;
      localStorage.setItem("highScore", highScore);
    }
    
    birdY = 200;
    birdVelocity = 0;
    pipes = [];
    score = 0;
    gameOver = false;
    scoreSaved = false;  // Reset score saved flag
    frames = 0;
  }
  
  function saveScoreToDatabase(score) {
    let playerName;
    {% if user.is_authenticated %}
    save = prompt("Save score to leaderboard? (y/n)");
    if (save === "y") {
      playerName = "{{ user.username }}";
    } else {
      playerName = null;
    }
    {% else %}
    save = prompt("Save score to leaderboard? (y/n)");
    if (save === "y") {
      playerName = prompt("Enter your name for the leaderboard:", "Anonymous");
    } else {
      playerName = null;
    }
    {% endif %}
    
    if (playerName !== null) {
      saveScore(playerName, score);
    }
  }
  
  function saveScore(playerName, score) {
    fetch("{% url 'flappyBird:save_score' %}", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': '{{ csrf_token }}'
      },
      body: JSON.stringify({
        player_name: playerName,
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        console.log("Score saved successfully!");
      } else {
        console.error("Failed to save score:", data.error);
      }
    })
    .catch(error => {
      console.error("Error saving score:", error);
    });
  }

  function flap() {
    if (gameOver) {
      resetGame();
    }
    birdVelocity = FLAP;
  }

  // Pointer input (works on mobile and desktop)
  canvas.addEventListener("pointerdown", () => {
    if (!flapQueued) {
      flap();
      flapQueued = true;
    }
  });

  canvas.addEventListener("pointerup", () => {
    flapQueued = false;
  });

  function drawBird() {
    ctx.fillStyle = birdColor;
    ctx.fillRect(80, birdY, BIRD_SIZE, BIRD_SIZE);
  }

  function drawPipes() {
    ctx.fillStyle = pipeColor;
    for (let pipe of pipes) {
      ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.top);
      ctx.fillRect(pipe.x, pipe.top + PIPE_GAP, PIPE_WIDTH, canvas.height - pipe.top - PIPE_GAP);
    }
  }

  function updatePipes() {
    if (frames % PIPE_SPACING === 0) {
      let topHeight = Math.floor(Math.random() * (canvas.height - PIPE_GAP - 100)) + 50;
      pipes.push({ x: canvas.width, top: topHeight, passed: false });
    }

    for (let pipe of pipes) {
      pipe.x -= PIPE_SPEED;

      // Collision detection
      if (
        80 + BIRD_SIZE > pipe.x &&
        80 < pipe.x + PIPE_WIDTH &&
        (birdY < pipe.top || birdY + BIRD_SIZE > pipe.top + PIPE_GAP)
      ) {
        gameOver = true;
        // Save score when bird hits pipe (only once)
        if (score > 0 && !scoreSaved) {
          saveScoreToDatabase(score);
          scoreSaved = true;
        }
      }

      // Score update
      if (!pipe.passed && pipe.x + PIPE_WIDTH < 80) {
        score++;
        pipe.passed = true;
      }
    }

    pipes = pipes.filter(pipe => pipe.x + PIPE_WIDTH > 0);
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBird();
    drawPipes();

    birdVelocity += GRAVITY;
    birdY += birdVelocity;

    if (birdY + BIRD_SIZE > canvas.height || birdY < 0) {
      gameOver = true;
      // Save score when game ends (only once)
      if (score > 0 && !scoreSaved) {
        saveScoreToDatabase(score);
        scoreSaved = true;
      }
    }

    if (!gameOver) {
      updatePipes();
    } else {
      ctx.fillStyle = "black";
      ctx.font = "30px Arial";
      ctx.fillText("Game Over!", 120, 250);
      ctx.font = "20px Arial";
      ctx.fillText("Tap to Restart", 120, 300);
    }

    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.fillText("Score: " + score, 10, 30);
    ctx.fillText("High Score: " + highScore, 10, 60);

    frames++;
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</div>
{% endblock %}
